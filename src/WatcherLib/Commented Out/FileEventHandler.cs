//# nullable enable

//using PW.FailFast;
//using System;
//using System.Collections.Generic;
//using System.IO;
//using System.Linq;
//using static ImageDeduper.Globals;

//namespace ImageDeduper
//{


//  /// <summary>
//  /// Class to handle events generated by the FileSystemWatcher class. Thread-safe.
//  /// </summary>

//  public class FileEventHandler
//  {
//    private class Operation
//    {
//      const byte InitialRetriesRemainging = 3;

//      internal Operation(FileSystemEventArgs e)
//      {
//        FilePath = e.FullPath;
//        ChangeType = e.ChangeType;
//        RetriesRemaining = InitialRetriesRemainging;
//        if (e is RenamedEventArgs r) OldFilePath = r.OldFullPath;
//      }

//      internal Operation(WatcherChangeTypes changeType, string filePath)
//      {
//        FilePath = filePath;
//        ChangeType = changeType;
//        RetriesRemaining = InitialRetriesRemainging;
//      }

//      public string FilePath { get; }

//      public string? OldFilePath { get; }

//      public WatcherChangeTypes ChangeType { get; }

//      public byte RetriesRemaining { get; }

//    }

//    private readonly object _listLock;

//    private List<Operation> Operations { get; set; }

//    public FileEventHandler()
//    {
//      _listLock = new object();
//      Operations = new List<Operation>();
//    }

//    /// <summary>
//    /// Checks the list for a pending operation with the same file path. 
//    /// </summary>
//    private Operation? TryFindEntryWithDuplicateFilePath(string path) => Operations.FirstOrDefault(x => FilePathsMatch(x.FilePath, path));

//    public void FileSystemEventHandler(object sender, FileSystemEventArgs e)
//    {
//      Guard.NotNull(e, nameof(e));

//      var current = new Operation(e);

//      lock (_listLock)
//      {
//        if (TryFindEntryWithDuplicateFilePath(e.FullPath) is Operation existing)
//        {
//          // There is already an operation pending for the same file-path.
//          // The action to take is determined by the ChangeType of both the pending and new operation.
//          HandleDuplicateFileOperation(existing, current);
//        }
//        else
//        {
//          Operations.Add(current);
//        }

//      }
//    }

//    private void HandleDuplicateWhenCurrentIsCreated(Operation existing, Operation current)
//    {
//      // LOGIC:
//      // 1. Both are created    -> Leave existing, drop current
//      // 2. Existing is deleted -> Remove existing, add current as changed
//      // 3. Existing is changed -> Leave existing, drop current
//      // 4. Existing is renamed ->  Change existing to be a delete, using old path. Add current. [This case seems unlikely]

//      throw new NotImplementedException();
//    }

//    private void HandleDuplicateWhenCurrentIsDeleted(Operation existing, Operation current)
//    {
//      // LOGIC:
//      // 1. both are delete    -> leave existing, drop current
//      // 2. existing is create -> remove existing, drop current.
//      // 3. existing is change -> remove existing, add current
//      // 4. existing is rename -> remove existing. db will still have old name. Add current, but using file path from existing.

//      // 1. Leave existing, drop current.
//      if (existing.ChangeType == WatcherChangeTypes.Deleted) return;

//      // Existing removed for all logic 2,3,4
//      Operations.Remove(existing);

//      // 2. remove existing, drop current.
//      if (existing.ChangeType == WatcherChangeTypes.Created) return;

//      // 3. remove existing, add current
//      if (existing.ChangeType == WatcherChangeTypes.Changed) Operations.Add(current);

//      // 4. remove existing. db will still have old file path. Add current, but using file path from existing.
//      else Operations.Add(new Operation(WatcherChangeTypes.Deleted, existing.OldFilePath!));

//    }

//    private void HandleDuplicateWhenCurrentIsChanged(Operation existing, Operation current)
//    {
//      throw new NotImplementedException();
//    }

//    private void HandleDuplicateWhenCurrentIsRenamed(Operation existing, Operation current)
//    {
//      throw new NotImplementedException();
//    }

//    private void HandleDuplicateFileOperation(Operation existing, Operation current)
//    {
//      // Created, Deleted, Changed, Renamed

//      switch (current.ChangeType)
//      {
//        case WatcherChangeTypes.Created:
//          HandleDuplicateWhenCurrentIsCreated(existing, current);
//          break;

//        case WatcherChangeTypes.Deleted:
//          HandleDuplicateWhenCurrentIsDeleted(existing, current);
//          break;

//        case WatcherChangeTypes.Changed:
//          HandleDuplicateWhenCurrentIsChanged(existing, current);
//          break;

//        case WatcherChangeTypes.Renamed:
//          HandleDuplicateWhenCurrentIsRenamed(existing, current);
//          break;

//        default: throw new InvalidOperationException($"Unsupported change type.");
//      }
//    }





//  }
//}
